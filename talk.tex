\documentclass[14pt]{beamer}
\usepackage{listings}
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage[scaled]{helvet}
\renewcommand*\familydefault{\sfdefault}

\lstset{
  basicstyle=\ttfamily\footnotesize
}

\title{Using OpenStreetMap data with Python}
\author{Andrii V. Mishkovskyi}
\date{\today}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Who is this dude?}
  \begin{itemize}
  \item I love Python
  \item I love OpenStreetMap
  \item I do map rendering at CloudMade using Python
  \item CloudMade uses OpenStreetMap data exclusively
  \end{itemize}
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{Introduction}

\subsection{Definitions}
\label{sec:definitions}

\begin{frame}
  \frametitle{Outline}
  \begin{itemize}
  \item Understanding OpenStreetMap data structure
  \item Building map services with Python
  \item Using Postgis to process data
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{OpenStreetMap}
  \begin{itemize}
  \item Crowd-sourced maps
  \item Free license (CC-by-SA -> ODBL)
  \item Good data coverage for Europe (most)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why OSM}
  \begin{itemize}
  \item Easy (except for starters)
  \item Quality (except for non-Europe)
  \item Free (without exceptions)
  \end{itemize}
\end{frame}

\section{Data layout}
\label{sec:diving}

\begin{frame}
  \frametitle{Data types}
  \begin{description}
  \item[Node] Geometric point or point of interest
  \item[Way] Collection of points
  \item[Relation] Collections of objects of any type
  \end{description}
\end{frame}

\begin{frame}
  \frametitle{The data}
  \begin{itemize}
  \item Each object has geometry, tags and changeset information
  \item Tags are simply a list of key/value pairs
  \item Geometry definition differs for different types
  \item Changeset information you shouldn't care about
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{How is it stored?}
  \begin{itemize}
  \item XML (.osm)
  \item Protocol buffers (beta, .pbf)
  \item Other formats through 3rd parties
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Nodes}
  \only<1>{\center{\lstinputlisting[language=XML]{nodes.xml}}}
  \only<2>{\lstinputlisting[language=Python]{nodes.py}}
\end{frame}

\begin{frame}
  \frametitle{Ways}
  \only<1>{\center{\lstinputlisting[language=XML]{ways.xml}}}
  \only<2>{\lstinputlisting[language=Python]{ways.py}}
\end{frame}

\begin{frame}
  \frametitle{Relations}
  \only<1>{\lstinputlisting[language=XML]{relations.xml}}
  \only<2>{\lstinputlisting[language=Python]{relations.py}}
\end{frame}

\section{Importing}
\label{sec:importing}

\begin{frame}
  \frametitle{Major points when parsing OSM}
  \only<1>{
    \begin{itemize}
    \item Expect faulty data
    \item Parse iteratively
    \item Cache extensively
    \item Order of elements is not guaranteed
    \item But it's generally: nodes, ways, relations
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Parsing data: nodes}
  \only<1>{
    \begin{itemize}
    \item Using SAX
    \item Just a simple node parser
    \item Create geometries using Shapely
    \end{itemize}}
  \only<2>{
    \lstinputlisting[firstline=3,lastline=10,language=Python]{nodes-simple.py}
  }
  \only<3>{
    \lstinputlisting[firstline=10,lastline=15,language=Python]{nodes-simple.py}
  }
\end{frame}

\begin{frame}
  \frametitle{Parsing data: ways}
  \only<1>{
    \begin{itemize}
    \item
    \end{itemize}}
  \only<2>{
    \lstinputlisting[firstline=3,lastline=10,language=Python]{ways-simple.py}
  }
  \only<3>{
    \lstinputlisting[firstline=10,lastline=15,language=Python]{ways-simple.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Backends}
  \begin{itemize}
  \item PostGIS
  \item MongoDB
  \item Spatialite
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Importing to PostGIS}
  \only<1>{
    \begin{itemize}
    \item Build schema
    \item Let database validate data
    \item Select projection before importing
    \item Use COPY statement
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting{import-postgis.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Importing to Mongo}
  \only<1>{
    \begin{itemize}
    \item No schema required
    \item Validate data in Python
    \item Don't reproject
    \item Use safe insert
    \end{itemize}
  }
  only<2>{
    \lstinputlisting{import-mongo.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Existing solutions}
  \begin{itemize}
  \item Osmosis
  \item osm2pgsql
  \item osm2mongo, osm2shp
  \end{itemize}
\end{frame}


\section{Rendering}

\subsection{Definitions}
\label{sec:definitions-1}

\begin{frame}
  \frametitle{Principles}
  \begin{itemize}
  \item Scale
  \item Projection
  \item Cartography
  \item Types of maps
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{How to approach rendering}
  \begin{itemize}
  \item Split your data in layers
  \item Make projection configurable
  \item Provide general way to select data sources
  \item Think about cartographers
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Layers}
  \begin{itemize}
  \item Not exactly physical layers
  \item Layers of graphical representation
  \item Don't render text in several layers
  \end{itemize}
\end{frame}

\subsection{Mapnik}

\begin{frame}
  \frametitle{The magic of Mapnik}
  \lstinputlisting[language=Python]{mapnik-overview.py}
\end{frame}

\begin{frame}
  \frametitle{Magic?}
  \begin{itemize}
  \item Mapnik's interface is straightforward
  \item The implementation is not
  \item Complexity is hidden in XML
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Mapnik's XML}
  \only<1>{
    \lstinputlisting[language=XML]{mapnik-style.xml}
  }
  \only<2>{
    \lstinputlisting[language=XML]{mapnik-layer.xml}
  }
\end{frame}


\begin{frame}
  \frametitle{Rendering sketch}
  \only<1>{
    \begin{itemize}
    \item Choose rendering library (pycairo, aggdraw, PIL?)
    \item Make a decision about error handling
    \item Support as many formats as possible (through GDAL, GeoAlchemy, etc.)
    \item Shapely for geometries, PyProj for projections
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting[language=Python]{rendering-overview.py}
  }
  \only<3>{
    \lstinputlisting[language=Python]{rendering-nodes.py}
  }
  \only<4>{
    \lstinputlisting[language=Python]{rendering-ways.py}
  }
\end{frame}

% TODO add dos and donts?

% postgis indexes!!! wsdfd

\section{Searching}

\begin{frame}
  \frametitle{What's that?}
  \begin{itemize}
  \item Codename geocoding
  \item Similar to magnets
  \item Fast or correct -- choose one
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why is it hard?}
  \only<1>{
    \begin{itemize}
    \item Fuzzy search
    \item Order matters
    \item But not always
    \item One place can have many names
    \item One name can correspond to many places
    \item People don't care about this at all!
    \end{itemize}
  }
  \only<2>{
    \begin{center}
      \LARGE{I blame Google.}
    \end{center}
  }
\end{frame}

\begin{frame}
  \frametitle{Attempt at implementation}
  \only<1>{
    \begin{itemize}
    \item Put restrictions
    \item Make the request structured
    \item Or at least assume order
    \item Assume valid input from users
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting[language=Python]{structured-geocoding-prototype.py}
  }
  \only<3>{
    \lstinputlisting[language=Python]{structured-geocoding-inner.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Fixing user input}
  \only<3>{
    Edit distance
    \begin{itemize}
    \item Works for two words
    \item Most geocoding requests consist of several words
    \item Scanning database for each pair distance isn't feasible
    \item Unless you have it cached already
    \end{itemize}
  }
  \only<4>{
    \lstinputlisting[language=Python]{geocoding-editdistance.py}
  }
  \only<1>{
    Soundex/Metaphone/DoubleMetaphone hashing
    \begin{itemize}
    \item Phonetic hashing
    \item Works in 90\% of the cases
    \item If your language is English
    \item Doesn't work well for placenames
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting[language=Python]{geocoding-soundex.py}
  }
  \only<5>{
    N-grams
    \begin{itemize}
    \item Useful for finding ``similarity''
    \item Easier to index than edit distance
    \item Gives less false positives than phonetic hashes
    \item Trigrams most commonly used
    \end{itemize}
  }
  \only<6>{
    \lstinputlisting[language=Python]{geocoding-trigrams.py}
  }
\end{frame}

\begin{frame}
  \frametitle{Making the search free-form}
  \only<1>{
    \begin{itemize}
    \item Normalize input: remove the, a, \ldots
    \item Use existing free-form search solution
    \item Combine ranks from different sources
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting{geocoding-freeform.py}
  }
\end{frame}

\begin{frame}
  \frametitle{Options to consider}
  \begin{itemize}
  \item PostreSQL + PostGIS
  \item Geocommons
  \item Nominatim
  \end{itemize}
\end{frame}

\section{Routing}

\begin{frame}
  \frametitle{The problem}
  \only<1>{
    When introduced with routing problem, people think
    Build graph, use Dijsktra, you're done!
    (And they are mostly right)
  }
  \only<2>{
    Not that simple
    \begin{itemize}
    \item Graph is sparse
    \item Graph has to be updated often
    \item Dijkstra algorithm is too general
    \item A* is no better
    \end{itemize}
  }
  \only<3>{
    \begin{itemize}
    \item Routing is not only a technical problem
    \item Different people expect different results for the same input
    \item
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Building the graph}
  \only<1>{
    \begin{itemize}
    \item Adjacency matrix is not space-efficient
    \item The graph representation has to very compact
    \item networkx and igraph are both pretty good for a start
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting[language=Python]{routing-networkx.py}
  }
  \only<3>{
    \begin{itemize}
    \item There is no silver bullet
    \item No matter how nice these libs are, importing even
      Europe will require more than 20 GB of RAM
    \item Splitting data into country graphs is not enough
    \item Our in-house C++ graph library requires ~20GB
      of mem for the whole world
    \end{itemize}
  }
\end{frame}


\begin{frame}
  \frametitle{Other solutions}
  \begin{itemize}
  \item PgRouting -- easier to start with, couldn't make it fast,
    harder to configure
  \item Neo4j -- tried 2 years ago, proved to be lacking when
    presented with huge sparse graphs
  \item Eat your own dogfood -- if doing ``serious business'', most
    probably the best solution. Half-wink.
  \end{itemize}
\end{frame}

\section*{Summary}

\begin{frame}
  \begin{center}
    \only<1>{\LARGE{Bored already?}}
    \only<2>{\LARGE{Lighten up, I'm done}}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Highlights}
  \begin{itemize}
  \item Start using OpenStreetMap data -- it's easy
  \item Try building something simple -- it's cool
  \item Try building something cool -- it's simple
  \item Python is one of the best languages [for doing GIS]
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \LARGE{Questions?}
  \end{center}
  \vfill
  \begin{center}
    \texttt{contact@mishkovskyi.net}\\
    Slides: \texttt{mishkovskyi.net/ep2011}
  \end{center}
\end{frame}



% http://norvig.com/spell-correct.html




% GIN, GIS, n-grams, levenshtein distance

%% Existing solutions
%% Structured search
%% Fuzzy search
%% Levenstein distance
%% Adding
%% Trigrams
%% PostgreSQL full-text search
%% Why not Soundex/Metaphone/Double metaphone


%% Intro

%% What's OSM
%% License
%% Data quality ?

%% Import

%% How data looks
%% How to use lxml or protobuf for parsing
%% Choosing data storage -- PostGIS, not MySQL or MongoDB or ...
%% General import layout

%% Some benchmarks
%% Some code
%% Some funny images

%% Tiles

%% Rendering
%% Mapnik, etc
%% How to write your renderer
%% Scale the motherfucker

%% Geocoding

%% Routing

%% Building graphs
%% Why importing is harder for routing
%% Pygraph, networkx, igraph

%% TODO: situation where looping would be used constantly

\end{document}
