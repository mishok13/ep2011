\documentclass[14pt]{beamer}
\usepackage{listings}
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage[scaled]{helvet}
\renewcommand*\familydefault{\sfdefault}

\lstset{
  basicstyle=\ttfamily
}

\title{Using OpenStreetMap data with Python}
\author{Andrii V. Mishkovskyi}
\date{\today}


\begin{document}

% \begin{frame}{Test}
%   \begin{center}
%     \lstinputlisting[language=Python]{./importing.py}
%   \end{center}
% \end{frame}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \tableofcontents
\end{frame}

\section{Introduction}

\subsection{Definitions}
\label{sec:definitions}

\begin{frame}
  \frametitle{Outline}
  \begin{itemize}
  \item Understanding OpenStreetMap data structure
  \item Building map services with Python
  \item Using Postgis to process data
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{OpenStreetMap}
  \begin{itemize}
  \item Crowd-sourced maps
  \item Free license (CC-by-SA -> ODBL)
  \item Good data coverage for Europe (most)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why OSM}
  \begin{itemize}
  \item Easy (except for starters)
  \item Quality (except for non-Europe)
  \item Free (without exceptions)
  \end{itemize}
\end{frame}

\section{Data layout}
\label{sec:diving}

\begin{frame}
  \frametitle{Data types}
  \begin{description}
  \item[Node] Geometric point or point of interest
  \item[Way] Collection of points
  \item[Relation] Collections of objects of any type
  \end{description}
\end{frame}

\begin{frame}
  \frametitle{The data}
  \begin{itemize}
  \item Each object has geometry, tags and changeset information
  \item Tags are simply a list of key/value pairs
  \item Geometry definition differs for different types
  \item Changeset information you shouldn't care about
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{How is it stored?}
  \begin{itemize}
  \item XML (.osm)
  \item Protocol buffers (beta, .pbf)
  \item Other formats through 3rd parties
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Nodes}
  % TODO: add more text before actual xml and python
  \only<1>{}
  \only<2>{\center{\lstinputlisting[language=XML]{nodes.xml}}}
  \only<3>{\lstinputlisting[language=Python]{nodes.py}}
\end{frame}

\begin{frame}
  \frametitle{Ways}
  \only<1>{test}
  \only<2>{\center{\lstinputlisting[language=XML]{ways.xml}}}
  \only<3>{\lstinputlisting[language=Python]{ways.py}}
\end{frame}

\begin{frame}
  \frametitle{Relations}
  \only<1>{test}
  \only<2>{\lstinputlisting[language=XML]{relations.xml}}
  \only<3>{\lstinputlisting[language=Python]{relations.py}}
\end{frame}


\section{Importing}
\label{sec:importing}

\begin{frame}
  \frametitle{Major points when parsing OSM}
  \only<1>{
    \begin{itemize}
    \item Expect faulty data
    \item Parse iteratively
    \item Cache extensively
    \item Order of elements is not guaranteed
    \item But it's generally: nodes, ways, relations
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Parsing data: nodes}
  \only<1>{
    \begin{itemize}
    \item Using SAX
    \item Just a simple node parser
    \item Create geometries using Shapely
    \end{itemize}}
  \only<2>{
    \lstinputlisting[firstline=3,lastline=10,language=Python]{nodes-simple.py}
  }
  \only<3>{
    \lstinputlisting[firstline=10,lastline=15,language=Python]{nodes-simple.py}
  }
\end{frame}

\begin{frame}
  \frametitle{Parsing data: ways}
  \only<1>{
    \begin{itemize}
    \item
    \end{itemize}}
  \only<2>{
    \lstinputlisting[firstline=3,lastline=10,language=Python]{ways-simple.py}
  }
  \only<3>{
    \lstinputlisting[firstline=10,lastline=15,language=Python]{ways-simple.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Backends}
  \begin{itemize}
  \item PostGIS
  \item MongoDB
  \item Spatialite
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Importing to PostGIS}
  \only<1>{
    \begin{itemize}
    \item Build schema
    \item Let database validate data
    \item Select projection before importing
    \item Use COPY statement
    \end{itemize}
  }
  only<2>{
    \lstinputlisting{import-postgis.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Importing to Mongo}
  \only<1>{
    \begin{itemize}
    \item No schema required
    \item Validate data in Python
    \item Don't reproject
    \item Use safe insert
    \end{itemize}
  }
  only<2>{
    \lstinputlisting{import-mongo.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Existing solutions}
  \begin{itemize}
  \item Osmosis
  \item osm2pgsql
  \item osm2mongo, osm2shp
  \end{itemize}
\end{frame}


\section{Rendering}

\subsection{Definitions}
\label{sec:definitions-1}

\begin{frame}
  \frametitle{Principles}
  \begin{itemize}
  \item Scale
  \item Projection
  \item Cartography
  \item Types of maps
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{How to approach rendering}
  \begin{itemize}
  \item Split your data in layers
  \item Make projection configurable
  \item Provide general way to select data sources
  \item Think about cartographers
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Layers}
  \begin{itemize}
  \item Not exactly physical layers
  \item Layers of graphical representation
  \item Don't render text in several layers
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Rendering sketch}
  \only<1>{
    \begin{itemize}
    \item Choose rendering library (pycairo, aggdraw, PIL?)
    \item Make a decision about error handling
    \item Support as many formats as possible (through GDAL, GeoAlchemy, etc.)
    \item Shapely for geometries, PyProj for projections
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting[language=Python]{rendering-overview.py}
  }
  \only<3>{
    \lstinputlisting[language=Python]{rendering-nodes.py}
  }
  \only<4>{
    \lstinputlisting[language=Python]{rendering-ways.py}
  }
\end{frame}

% TODO add dos and donts?

\begin{frame}
  \frametitle{A better option}
  \only<1->{
    Mapnik
  }
  \only<2->{
    \begin{itemize}
    \item Written in C++, with bindings through Boost.Python
    \item Feature-rich
    \item Reasonably fast
    \item Uses XML for styles
    \end{itemize}
  }
\end{frame}

postgis indexes!!! wsdfd

\section{Searching}

\begin{frame}
  \frametitle{What's that?}
  \begin{itemize}
  \item Codename geocoding
  \item Similar to magnets
  \item Fast or correct -- choose one
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Why is it hard?}
  \only<1>{
    \begin{itemize}
    \item Fuzzy search
    \item Order matters
    \item But not always
    \item One place can have many names
    \item One name can correspond to many places
    \item People don't care about this at all!
    \end{itemize}
  }
  \only<2>{
    \begin{center}
      \LARGE{I blame Google.}
    \end{center}
  }
\end{frame}

\begin{frame}
  \frametitle{Attempt at implementation}
  \only<1>{
    \begin{itemize}
    \item Put restrictions
    \item Make the request structured
    \item Or at least assume order
    \item Assume valid input from users
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting[language=Python]{structured-geocoding-prototype.py}
  }
  \only<3>{
    \lstinputlisting[language=Python]{structured-geocoding-inner.py}
  }
\end{frame}


\begin{frame}
  \frametitle{Fixing user input}
  \only<1>{
    Edit distance
    \begin{itemize}
    \item Works for two words
    \item Most geocoding requests consist of several words
    \item Scanning database for each pair distance isn't feasible
    \item Unless you have it cached already
    \end{itemize}
  }
  \only<2>{
    Soundex/Metaphone hashing
    \begin{itemize}
    \item Phonetic hashing
    \item Works in 90\% of the cases
    \item If your language is English
    \item Doesn't work well for placenames
    \end{itemize}
  }
  \only<3>{
    N-grams
    \begin{itemize}
    \item Useful for finding ``similarity''
    \item Easier to index than edit distance
    \item Gives less false positives than phonetic hashes
    \item Trigrams most commonly used
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Making the search a tad free-form}
  \only<1>{
    \begin{itemize}
    \item Ranking every word would be a good start
    \item Remove ``stop words'' -- at, the, in, \ldots
    \item Combining ranks is harder
    \end{itemize}
  }
  \only<2>{
    \lstinputlisting{geocoding-freeform.py}
  }
\end{frame}

\begin{frame}
  \frametitle{Options to consider}
  \begin{itemize}
  \item Geocommons
  \item Nominatim
  \end{itemize}
\end{frame}


\section{Routing}

\begin{frame}
  \frametitle{The problem}
  \only<1>{
    When introduced with routing problem, people think
    Build graph, use Dijsktra, you're done!
  }
  \only<2>{
    Not that simple
    \begin{itemize}
    \item Graph is sparse
    \item Graph has to be updated often
    \item Dijkstra algorithm is too general
    \item A* is no better
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Building the graph}
  \begin{itemize}
  \item Don't use adjacency matrix
  \item The graph has to very compact
  \item networkx and igraph are a pretty good start
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{PgRouting}
  \begin{itemize}
  \item Somewhat slow
  \item Hard to correctly import data
  \item
  \end{itemize}
\end{frame}



% http://norvig.com/spell-correct.html




% GIN, GIS, n-grams, levenshtein distance

%% Existing solutions
%% Structured search
%% Fuzzy search
%% Levenstein distance
%% Adding
%% Trigrams
%% PostgreSQL full-text search
%% Why not Soundex/Metaphone/Double metaphone


%% Intro

%% What's OSM
%% License
%% Data quality ?

%% Import

%% How data looks
%% How to use lxml or protobuf for parsing
%% Choosing data storage -- PostGIS, not MySQL or MongoDB or ...
%% General import layout

%% Some benchmarks
%% Some code
%% Some funny images

%% Tiles

%% Rendering
%% Mapnik, etc
%% How to write your renderer
%% Scale the motherfucker

%% Geocoding

%% Routing

%% Building graphs
%% Why importing is harder for routing
%% Pygraph, networkx, igraph

\end{document}
